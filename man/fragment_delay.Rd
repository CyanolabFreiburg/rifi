% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fragment_delay.r
\name{fragment_delay}
\alias{fragment_delay}
\title{fragment_delay: performs the delay fragmentation.
fragment_delay makes delay_fragments based on position_segments and assigns
all gathered information to the probe based data frame.
The columns "delay_fragment", "velocity_fragment", "intercept" and "slope"
are added.
fragment_delay makes delay_fragments, assigns slopes, which are 1/velocity
at the same time, and intercepts for the TU calculation.
The function used is:
.score_fun_linear
the input is the probe, a data frame with ID, delay, position,
position_segment and strand.
pen is the penalty for new fragments in the dynamic programming, pen_out is
the outlier penalty.}
\usage{
fragment_delay(probe, cores = 1, pen, pen_out)
}
\arguments{
\item{probe}{data frame: the probe based data frame.}

\item{cores}{cores: integer: the number of assigned cores for the task.}

\item{pen}{numeric: an internal parameter for the dynamic programming.
Higher values result in fewer fragments. Default is the auto generated value.}

\item{pen_out}{numeric: an internal parameter for the dynamic programming.
Higher values result in fewer allowed outliers. Default is the auto generated
value.}
}
\value{
the probe data frame with the columns regarding the delay:
delay_fragment, velocity_fragment, intercept and slope:
\describe{
\item{ID:}{The bin/probe specific ID}
\item{position:}{The bin/probe specific position}
\item{strand:}{The bin/probe specific strand}
\item{position_segment:}{The position based segment}
\item{delay:}{The delay value of the bin/probe}
\item{delay_fragment:}{The delay fragment the bin belongs to}
\item{velocity_fragment:}{The velocity value of the respective delay
fragment}
\item{intercept:}{The vintercept of fit through the respective delay
fragment}
\item{slope:}{The slope of the fit through the respective delay fragment}
}
}
\description{
fragment_delay: performs the delay fragmentation.
fragment_delay makes delay_fragments based on position_segments and assigns
all gathered information to the probe based data frame.
The columns "delay_fragment", "velocity_fragment", "intercept" and "slope"
are added.
fragment_delay makes delay_fragments, assigns slopes, which are 1/velocity
at the same time, and intercepts for the TU calculation.
The function used is:
.score_fun_linear
the input is the probe, a data frame with ID, delay, position,
position_segment and strand.
pen is the penalty for new fragments in the dynamic programming, pen_out is
the outlier penalty.
}
\examples{
data(fragmentation_minimal)
data(penalties_minimal)
fragment_delay(
  probe = fragmentation_minimal, cores = 2,
  pen = penalties_minimal["delay_penalty"],
  pen_out = penalties_minimal["delay_outlier_penalty"]
)

}
